##########################################
#####  Problems of life (and death)  #####
######  Oliver Snellman 20.11.2019  ######
#######       Version: 1.3         #######
##########################################


## This is an unfinished document to help tackle the empirical excercise of Problem set 2.
## I will update this document every time I make progress, also updating the version number in the header.
## Copy-paste the code on your R-Studio and execute the lines by ctrl + enter.


# Utilize packages needed. If they are already installed once, only conduct the second of the lapply-commands.
pkgs <- c("tidyverse", "data.table", "readxl", "httr")
lapply(pkgs, install.packages, character.only=TRUE)
lapply(pkgs, library, character.only=TRUE)

# Set the working directory
setwd("Z:/Exercises") # Insert your own folder

par(mfrow=c(1,1)) # Reset the plotting settings



#################### Advanced Econometrics 2, Excercise 2 #################### 

# Import the data straight from the website and save as a dataframe "data". "data" has 758 rows (observations) and 20 columns (variables)
url<-'https://sites.google.com/site/fumiohayashi/hayashi-econometrics/data-for-empirical/grilic.xls'
GET(url, write_disk(tf <- tempfile(fileext = ".xls")))
data <- read_excel(tf, 1L)

# OR download the xls-file from https://sites.google.com/site/fumiohayashi/hayashi-econometrics/data-for-empirical and use the following:
data <- read_xls("grilic.xls")

# Variable names and respective column numbers
vars <- cbind(c(1:ncol(data)), names(data))


#####################################
## a)

# Calculate means and standard deviations for the variables
means <- apply(X=data, MARGIN=2, FUN=mean)
deviations <- apply(X=data, MARGIN=2, FUN=sd)

# Calculate the correlation between IQ and S. Square brackets are used to choose the required columns from the matrix "data" 
corr_iq_s <- cov(data[,8],data[,13])/sqrt(deviations[,8]^2 * deviations[,13]^2)

# Generate year dummies for years 66-71 and 73
year_dummy_generator <- function(input){
    n_outputs <- length(unique(input))
    years <- sort(unique(input))
    output <- matrix(0, nrow=length(input), ncol=n_outputs)
    
    for(i in 1:length(input)){
        for(j in 1:n_outputs){
            # if(is.na(input[[i]])) output[i,] <- NA
            if(input[[i]] == years[[j]]){
                output[i,j] <- 1
                break
            }
        }
    }
    
    colnames(output) <- c(66:71,73)
    
    return(output)
}

year_dummies <- year_dummy_generator(data[[10]])


# cbind(data[[10]], as.matrix(year_dummies)) # Check whether the one hot encoding was correct

# Append the dataset with the new year dummy -variables
data2 <- cbind(data, year_dummies)
var_names <- cbind(c(1:ncol(data2)), names(data2))



#####################################
## b) Regression model without an intercept

# Explained variables
log_wages <- data2[,19]

# Explanatory variables
schooling <- data2[,13]
iq <- data2[,8]
expr <- data2[,15]
tenure <- data2[,17]
rns <- data2[,1]
smsa <- data2[,5,]
year66 <- data2[,21]
year67 <- data2[,22]
year68 <- data2[,23]
year69 <- data2[,24]
year70 <- data2[,25]
year71 <- data2[,26]
year73 <- data2[,27]

z <- cbind(schooling, iq, expr, tenure, rns, smsa,
           year66, year67, year68, year69, year70, year71, year73) # Year dummies

# Additional instruments
med <- data2[,7]
kww <- data2[,9]
mrt <- data2[,3]
age <- data2[,11]

x <- cbind(schooling, expr, tenure, rns, smsa,
           year66, year67, year68, year69, year70, year71, year73,
           med, kww, mrt, age)


# Ordinary Least Squares
beta_ols <- solve(t(z) %*% z) %*% t(z) %*% log_wages
y_hat_ols <- z%*%beta_ols

# Regression coefficients
print(round(beta_ols, 4))

# Additional

# Plot the ordered wage series and the ols estimate
ordered <- cbind(c(1:length(log_wages)), log_wages, y_hat_ols)
ordered <- ordered[order(log_wages),]

plot(ordered[,2])
lines(ordered[,3], col="blue")
legend("topleft", legend=c("log wages", "ols estimate"), col=c("black", "blue"), lty=c(1), cex=1.2, box.lty=1)         




## 2SLS


# 2SLS on one go
S_xz <- t(x) %*% z
S_xx <- t(x) %*% x
S_xy <- t(x) %*% log_wages

theta_2SLS <- solve(t(S_xz) %*% solve(S_xx) %*% (S_xz)) %*% t(S_xz) %*% solve(S_xx) %*% (S_xy)
y_hat <-  %*% theta_2SLS # What should the theta be multiplied with? If you made this far, you deserve a good champ medal even without the answer!

# Coefficients
print(round(theta_2SLS, 4))



#####################################
## c) Sargan's statistic. Should be 87.655
g <- list()
for(i in 1:length(y)) g[[i]] <- x[i,] %*% (y[[i]] - t(z[i,]) %*% theta_2SLS)



#####################################
## d) Obtain 2SLS by running two regressions.

# First stage: Project explanatory variables z on the column space of instruments x.
beta_x <- solve(t(x) %*% x) %*% t(x) %*% z
z_hat <- x %*% beta_x

# Second stage: Project the explained variable y on the space spanned by z_hat matrix
theta_2sls <- solve(t(z_hat) %*% z_hat) %*% (t(z_hat) %*% y)
y_hat <- z_hat%*%theta_2sls

# Coefficients
print(round(theta_2sls, 4))

solve(t(solve(t(x) %*% x) %*% t(x) %*% z) %*% solve(t(x) %*% x) %*% t(x) %*% z) %*% t(solve(t(x) %*% x) %*% t(x) %*% z) %*%y

ts.plot(y)
lines(y_hat, col="red")

length(y)


#####################################
## e) Endogenous schooling


#####################################
## f) Estimate wage equation by GMM


#####################################
## g) Drop MED and KWW from instruments













########################################################################

# Advanced Micro 2, Problem 6

problem6 <- function(n, beta){
    
    utility <- c()
    jump <- 1/n
    investing <- c(jump)
    
    for(i in 1:(n-1)){
        
        investing[[i+1]] <- investing[[i]] + jump
        
        # Utilities
        first <- log(1-investing[[i]])
        second <- 0.5*log(investing[[i]]) + 0.5*log(sqrt(investing[[i]]))
        
        utility[[i]] <- first + beta*second
        #cat("\n", i, ": Saving ", 100*round(investing[[i]],2), " % gives an expected utility of ", round(utility[[i]],3))
    }
    
    index <- which.max(utility)
    highest_utility <- max(utility)
    lowest_utility <- min(utility)
    optimal_saving <- investing[[index]]
    
    ts.plot(utility,
            gpars=list(xlab="Fractions", ylab="Utility", col=c("blue"), lwd=c(1), xaxt="n", ylim=c(lowest_utility-1, highest_utility)))
    abline(v=index, col="forestgreen", lty=2)
    text(index+n/13, highest_utility-1, "Optimal savings %", col = "forestgreen")
    text(index+n/13, highest_utility-1.5, 100*round(optimal_saving,4), col = "forestgreen")
    
    axis(side=1, at=seq(1, n, by=(n+n/8.5)/9), labels=c(seq(0.1, 0.9,by=0.1)))
    title("Impact of savings rate on utility in Micro Problem 6", line=0.4, adj=0.05, cex.main=1.2)
    legend("bottomleft", legend=c("Utility at different savings rates"), col=c("blue"), lty=c(1), cex=1.2, box.lty=1)
    
    cat("\n\n Optimal investing rate of ", 100*round(optimal_saving,4), " % gives a utility of : ", round(highest_utility,5))
}

problem6(n=10000, beta=1)




## Expected distance between two random points in a unit (hyper)box

length_between_random_points <- function(n, dim){
    distances <- c()
    
    for(i in 1:n){
        vector1 <- runif(dim, min=0, max=1)
        vector2 <- runif(dim, min=0, max=1)
        
        dist <- c()
        
        dist[[1]] <- vector1[[1]] - vector2[[1]]
        
        for(k in 2:dim){
            dist[[k]] <- sqrt((vector1[[k]] - vector2[[k]])^2 + dist[[k-1]]^2)
        }
        
        distances[[i]] <- dist[[dim]]
    
    }
    
    average_distance <- mean(distances)
    deviations <- sd(distances)
    
    cat("\n Average distance ", average_distance, " over ", n, " tries, with a standard deviation of ", deviations, "\n")
}

length_between_random_points(n=10000, dim=10000)















# Gale-Shapley algorithm: Stable marriage problem (Incomplete)

gale_shapley <- function(n_players, preferences_men, preferences_women){
    
    if(missing(preferences_men) && missing(preferences_women)){
        # Create men and women with preferences over each others
        
        preferences_men <- list()
        preferences_women <- list()
        
        for(i in 1:n_players){
            preferences_men[[i]] <- c(sample(c(1:n_players), n_players))
            preferences_women[[i]] <- c(sample(c(1:n_players), n_players))
        }
    }
        
        
        # Matching algorithm
        unstable <- TRUE
        rounds <- 1
        matches <- list()
        
        while(unstable){
            waiting_list <- list(rep(n_players, n_players+1))
            k <- 1
            
            for(i in 1:n_players){
                best_woman <- which(preferences_men[[i]] == k) # i'th man's best available choice
                waiting_list[[best_woman]] <- c(waiting_list[[best_woman]], )
                
            }
            
            
            if(unstable == FALSE) break
            
            rounds <- rounds + 1
            k <- k + 1
        }
    
        
    return(matches)
    
}



















