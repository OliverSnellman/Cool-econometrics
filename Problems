##########################################
#####  Problems of life (and death)  #####
######  Oliver Snellman 20.11.2019  ######
#######       Version: 1.2         #######
##########################################


## This is an unfinished document to help tackle the empirical excercise of Problem set 2.
## Copy-paste the code on your R-Studio and execute lines by ctrl + enter.


# Utilize packages needed. If they are already installed once, only conduct the second of the lapply-commands.
pkgs <- c("tidyverse", "data.table", "readxl", "httr")
lapply(pkgs, install.packages, character.only=TRUE)
lapply(pkgs, library, character.only=TRUE)

# Set the working directory
setwd("Z:/Exercises") # Insert your own folder

par(mfrow=c(1,1)) # Reset the plotting settings



#################### Advanced Econometrics 2, Excercise 2 #################### 

# Import the data straight from the website and save as a dataframe "data". "data" has 758 rows (observations) and 20 columns (variables)
url<-'https://sites.google.com/site/fumiohayashi/hayashi-econometrics/data-for-empirical/grilic.xls'
GET(url, write_disk(tf <- tempfile(fileext = ".xls")))
data <- read_excel(tf, 1L)

# OR download the xls-file from https://sites.google.com/site/fumiohayashi/hayashi-econometrics/data-for-empirical and use the following:
data <- read_xls("grilic.xls")

# Variable names and respective column numbers
vars <- cbind(c(1:ncol(data)), names(data))



# a)

# Calculate means and standard deviations for the variables
means <- apply(X=data, MARGIN=2, FUN=mean)
deviations <- apply(X=data, MARGIN=2, FUN=sd)

# Calculate the correlation between IQ and S. Square brackets are used to choose the required columns from the matrix "data" 
corr_iq_s <- cov(data[,8],data[,13])/sqrt(deviations[,8]^2 * deviations[,13]^2)

# Generate year dummies for years 66-71 and 73
year_dummy_generator <- function(input){
    n_outputs <- length(unique(input))
    years <- sort(unique(input))
    output <- matrix(0, nrow=length(input), ncol=n_outputs)
    
    for(i in 1:length(input)){
        for(j in 1:n_outputs){
            # if(is.na(input[[i]])) output[i,] <- NA
            if(input[[i]] == years[[j]]){
                output[i,j] <- 1
                break
            }
        }
    }
    
    colnames(output) <- c(66:71,73)
    
    return(output)
}

year_dummies <- year_dummy_generator(data[[10]])


# cbind(data[[10]], as.matrix(year_dummies)) # Check whether the one hot encoding was correct

# Append the dataset with the new year dummy -variables
data2 <- cbind(data, year_dummies)
var_names <- cbind(c(1:ncol(data2)), names(data2))




## b) Regression model without an intercept

# Name the variables of interest
log_wages <- data2[[19]]
schooling <- data2[[13]]
iq <- data2[[8]]


## Obtain the regression coefficients

# Old school
x <- cbind(schooling, iq, data2[[15]], data2[[17]], data2[[1]], data2[[5]],
           data2[[21]], data2[[22]], data2[[23]], data2[[24]], data2[[25]], data2[[26]], data2[[27]]) # Year dummies
beta.b <- solve(t(x)%*%x)%*%t(x)%*%log_wages
y_hat_b <- x%*%beta.b

ordered <- cbind(log_wages, c(1:length(log_wages)), y_hat_b)
ordered <- ordered[order(log_wages),]

plot(ordered[,1])
lines(ordered[,2], col="blue") # Not working correctly yet

# OR the loser way
model.b <- lm(log_wages ~ schooling + iq
            + data2[,15] + data2[,17] + data2[,1] + data2[,5]
            + data2[,21] + data2[,22] + data2[,23] + data2[,24] + data2[,25] + data2[,26] + data2[,27] -1, data2)
model.b




## 2SLS
# Instruments z: s, h, MED, KWW, MRT and AGE
x <- cbind(schooling, data2[,15], data2[,17], data2[,1], data2[,5],
                    data2[,21], data2[,22], data2[,23], data2[,24], data2[,25], data2[,26], data2[,27],
                    data2[,7], data2[,9], data2[,3], data2[,11])

# Variables x:
z <- cbind(schooling, data2[,8], data2[,15], data2[,17], data2[,1], data2[,5],
                      data2[,21], data2[,22], data2[,23], data2[,24], data2[,25], data2[,26], data2[,27])

# Explained variable y: Log wage
y <- data[[19]]


# 2SLS on one go
S_xz <- t(x)%*%z
S_xx <- t(x)%*%x
S_xy <- t(x)%*%y
beta_2SLS <- solve(t(S_xz)%*%solve(S_xx)%*%(S_xz))%*%t(S_xz)%*%solve(S_xx)%*%(S_xy)

y_hat <- x%*%beta_2SLS

ts.plot(y)
lines(y_hat, col="red")

length(y)


## c) Sargan's statistic. Should be 87.655
g <- list()
g[[i]] <- x[[]]


## d) Obtain 2SLS by running two regressions.

# First stage: Project explanatory variables x on the column space of instruments z.
beta_x <- solve(t(x)%*%x)%*%t(x)%*%z
z_hat <- x%*%beta_x

# Second stage: Project the explained variable y on the space spanned by z_hat matrix
beta_z <- solve(t(z_hat)%*%z_hat)*(t(z_hat)%*%y)
y_hat <- z_hat%*%beta_z


ts.plot(y)
lines(y_hat, col="red")

length(y)


## e) Endogenous schooling



## f) Estimate wage equation by GMM - nice!



## g) Drop MED and KWW from instruments













########################################################################

# Advanced Micro 2, Problem 6

problem6 <- function(n, beta){
    
    utility <- c()
    jump <- 1/n
    investing <- c(jump)
    
    for(i in 1:(n-1)){
        
        investing[[i+1]] <- investing[[i]] + jump
        
        # Utilities
        first <- log(1-investing[[i]])
        second <- 0.5*log(investing[[i]]) + 0.5*log(sqrt(investing[[i]]))
        
        utility[[i]] <- first + beta*second
        #cat("\n", i, ": Saving ", 100*round(investing[[i]],2), " % gives an expected utility of ", round(utility[[i]],3))
    }
    
    index <- which.max(utility)
    highest_utility <- max(utility)
    lowest_utility <- min(utility)
    optimal_saving <- investing[[index]]
    
    ts.plot(utility,
            gpars=list(xlab="Fractions", ylab="Utility", col=c("blue"), lwd=c(1), xaxt="n", ylim=c(lowest_utility-1, highest_utility)))
    abline(v=index, col="forestgreen", lty=2)
    text(index+n/13, highest_utility-1, "Optimal savings %", col = "forestgreen")
    text(index+n/13, highest_utility-1.5, 100*round(optimal_saving,4), col = "forestgreen")
    
    axis(side=1, at=seq(1, n, by=(n+n/8.5)/9), labels=c(seq(0.1, 0.9,by=0.1)))
    title("Impact of savings rate on utility in Micro Problem 6", line=0.4, adj=0.05, cex.main=1.2)
    legend("bottomleft", legend=c("Utility at different savings rates"), col=c("blue"), lty=c(1), cex=1.2, box.lty=1)
    
    cat("\n\n Optimal investing rate of ", 100*round(optimal_saving,4), " % gives a utility of : ", round(highest_utility,5))
}

problem6(n=10000, beta=1)




## Expected distance between two random points in a unit box

length_between_random_points <- function(n, dim){
    distances <- c()
    
    for(i in 1:n){
        vector1 <- runif(dim, min=0, max=1)
        vector2 <- runif(dim, min=0, max=1)
        
        dist <- c()
        
        dist[[1]] <- vector1[[1]] - vector2[[1]]
        
        for(k in 2:dim){
            dist[[k]] <- sqrt((vector1[[k]] - vector2[[k]])^2 + dist[[k-1]]^2)
        }
        
        distances[[i]] <- dist[[dim]]
    
    }
    
    average_distance <- mean(distances)
    deviations <- sd(distances)
    
    cat("\n Average distance ", average_distance, " over ", n, " tries, with a standard deviation of ", deviations, "\n")
}

length_between_random_points(n=10000, dim=10000)















# Gale-Shapley algorithm: Stable marriage problem

gale_shapley <- function(n_players, preferences_men, preferences_women){
    
    if(missing(preferences_men) && missing(preferences_women)){
        # Create men and women with preferences over each others
        
        preferences_men <- list()
        preferences_women <- list()
        
        for(i in 1:n_players){
            preferences_men[[i]] <- c(sample(c(1:n_players), n_players))
            preferences_women[[i]] <- c(sample(c(1:n_players), n_players))
        }
    }
        
        
        # Matching algorithm
        unstable <- TRUE
        rounds <- 1
        matches <- list()
        
        while(unstable){
            waiting_list <- list(rep(n_players, n_players+1))
            k <- 1
            
            for(i in 1:n_players){
                best_woman <- which(preferences_men[[i]] == k) # i'th man's best available choice
                waiting_list[[best_woman]] <- c(waiting_list[[best_woman]], )
                
            }
            
            
            if(unstable == FALSE) break
            
            rounds <- rounds + 1
            k <- k + 1
        }
    
        
    return(matches)
    
}




sample(c(1:5), 4)

?sample


















